---
title: 'wasm-bindgen'
sidebar_label: wasm-bindgen
---

[`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen) is a library and tool to facilitate
high-level interactions between Wasm modules and JavaScript; it is built with Rust by
[The Rust and WebAssembly Working Group](https://rustwasm.github.io/).

[`wasm-bindgen`](https://github.com/rustwasm/wasm-bindgen) æ˜¯ä¸€ä¸ªåœ¨ JavaScript å’Œ Rust å‡½æ•°ä¹‹é—´å»ºç«‹è°ƒç”¨æ¡¥æ¢çš„åº“å’Œå·¥å…·ã€‚å®ƒæ˜¯ç”± [Rust å’Œ WebAssembly å·¥ä½œç»„](https://rustwasm.github.io/) ä½¿ç”¨ Rust æ„å»ºçš„ã€‚

Yew uses `wasm-bindgen` to interact with the browser through a number of crates:

Yew ä½¿ç”¨ `wasm-bindgen` é€šè¿‡ä¸€äº› crate ä¸æµè§ˆå™¨è¿›è¡Œäº¤äº’ï¼š

-   [`js-sys`](https://crates.io/crates/js-sys)
-   [`wasm-bindgen`](https://crates.io/crates/wasm-bindgen)
-   [`wasm-bindgen-futures`](https://crates.io/crates/wasm-bindgen-futures)
-   [`web-sys`](https://crates.io/crates/web-sys)

This section will explore some of these crates at a high level, to make it easier to understand
and use `wasm-bindgen` APIs with Yew. For a more in-depth guide to `wasm-bindgen` and its associated
crates then check out [The `wasm-bindgen` Guide](https://rustwasm.github.io/docs/wasm-bindgen/).

æœ¬èŠ‚å°†ä»æ›´æŠ½è±¡çš„å±‚æ¬¡ä¸Šæ¢è®¨è¿™äº› crateï¼Œä»¥ä¾¿æ›´å®¹æ˜“åœ°ç†è§£å’Œä½¿ç”¨ Yew ä¸­çš„ `wasm-bindgen` APIã€‚è¦äº†è§£æœ‰å…³ `wasm-bindgen` åŠå…¶ç›¸å…³ crate çš„æ›´æ·±å…¥æŒ‡å—ï¼Œè¯·æŸ¥çœ‹ [`wasm-bindgen` æŒ‡å¼•](https://rustwasm.github.io/docs/wasm-bindgen/)ã€‚

For documentation on the above crates check out [`wasm-bindgen docs.rs`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/index.html).

æœ‰å…³ä¸Šè¿° crate çš„æ–‡æ¡£ï¼Œè¯·æŸ¥çœ‹ [`wasm-bindgen docs.rs`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/index.html)ã€‚

:::tip
Use the `wasm-bindgen` doc.rs search to find browser APIs and JavaScript types that have been imported
over using `wasm-bindgen`.

ä½¿ç”¨ `wasm-bindgen` doc.rs æœç´¢æ¥æŸ¥æ‰¾å·²ä½¿ç”¨ `wasm-bindgen` å¯¼å…¥çš„æµè§ˆå™¨ API å’Œ JavaScript ç±»å‹ã€‚
:::

## [`wasm-bindgen`](https://crates.io/crates/wasm-bindgen)

This crate provides many of the building blocks for the rest of the crates above. In this section we
are only going to cover two main areas of the `wasm-bindgen` crate and that is the macro and some
types/traits you will see pop up again and again.

è¿™ä¸ª crate ä¸ºä¸Šé¢çš„å…¶ä»– crate æä¾›äº†è®¸å¤šæ„å»ºå—ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬åªä¼šæ¶µç›– `wasm-bindgen` crate çš„ä¸¤ä¸ªä¸»è¦é¢†åŸŸï¼Œå³å®å’Œä¸€äº›æ‚¨ä¼šä¸€éåˆä¸€éçœ‹åˆ°çš„ç±»å‹/ç‰¹æ€§ã€‚

### `#[wasm_bindgen]` macro

The `#[wasm_bindgen]` macro provides an interface between Rust and JavaScript, providing a system
for translating between the two. Using this macro is more advanced, and you should not need to reach
for it unless you are trying to use an external JavaScript library. The `js-sys` and `web-sys`
crates expose `wasm-bindgen` definitions for built-in JavaScript types and browser APIs.

`#[wasm_bindgen]` å®æä¾›äº† Rust å’Œ JavaScript ä¹‹é—´çš„æ¥å£ï¼Œæä¾›äº†ä¸€ä¸ªåœ¨ä¸¤è€…ä¹‹é—´è¿›è¡Œè½¬æ¢çš„ç³»ç»Ÿã€‚ä½¿ç”¨è¿™ä¸ªå®æ›´ä¸ºé«˜çº§ï¼Œé™¤éæ‚¨è¦ä½¿ç”¨å¤–éƒ¨ JavaScript åº“ï¼Œå¦åˆ™ä¸åº”è¯¥ä½¿ç”¨å®ƒã€‚`js-sys` å’Œ `web-sys` crate ä¸ºå†…ç½® JavaScript ç±»å‹å’Œæµè§ˆå™¨ API æä¾›äº† `wasm-bindgen` å®šä¹‰ã€‚

Let's go over a simple example of using the `#[wasm-bindgen]` macro to import some specific flavours
of the [`console.log`](https://developer.mozilla.org/en-US/docs/Web/API/Console/log) function.

è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹æ¥ä½¿ç”¨ `#[wasm-bindgen]` å®æ¥å¯¼å…¥ä¸€äº›ç‰¹å®šç‰ˆæœ¬çš„ [`console.log`](https://developer.mozilla.org/en-US/docs/Web/API/Console/log) å‡½æ•°ã€‚

```rust ,no_run
use wasm_bindgen::prelude::*;

// First up let's take a look of binding `console.log` manually, without the
// help of `web_sys`. Here we're writing the `#[wasm_bindgen]` annotations
// manually ourselves, and the correctness of our program relies on the
// correctness of these annotations!
#[wasm_bindgen]
extern "C" {

    // Use `js_namespace` here to bind `console.log(..)` instead of just
    // `log(..)`
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    // The `console.log` is quite polymorphic, so we can bind it with multiple
    // signatures. Note that we need to use `js_name` to ensure we always call
    // `log` in JS.
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_u32(a: u32);

    // Multiple arguments too!
    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_many(a: &str, b: &str);
}

// using the imported functions!
log("Hello from Rust!");
log_u32(42);
log_many("Logging", "many values!");
```

_This example was adapted from [1.2 Using console.log of The `wasm-bindgen` Guide](https://rustwasm.github.io/docs/wasm-bindgen/examples/console-log.html)_.

_è¿™ä¸ªç¤ºä¾‹æ˜¯åŸºäº [1.2 ä½¿ç”¨ console.log çš„ `wasm-bindgen` æŒ‡å¼•](https://rustwasm.github.io/docs/wasm-bindgen/examples/console-log.html) æ”¹ç¼–çš„ã€‚_

### Simulating inheritance

### æ¨¡æ‹Ÿç»§æ‰¿

Inheritance between JavaScript classes is a core feature of the Javascript language and the DOM
(Document Object Model) is designed around it. When types are imported using `wasm-bindgen` you can
also add attributes that describe their inheritance.

åœ¨ JavaScript ç±»ä¹‹é—´çš„ç»§æ‰¿æ˜¯ JavaScript è¯­è¨€çš„æ ¸å¿ƒç‰¹æ€§ï¼ŒDOMï¼ˆæ–‡æ¡£å¯¹è±¡æ¨¡å‹ï¼‰æ˜¯å›´ç»•å®ƒè®¾è®¡çš„ã€‚å½“ä½¿ç”¨ `wasm-bindgen` å¯¼å…¥ç±»å‹æ—¶ï¼Œæ‚¨è¿˜å¯ä»¥æ·»åŠ æè¿°å®ƒä»¬ç»§æ‰¿å…³ç³»çš„å±æ€§ã€‚

In Rust, this inheritance is represented using the [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html)
and [`AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) traits. An example of this
might help; so say you have three types `A`, `B`, and `C` where `C` extends `B` which in turn
extends `A`.

åœ¨ Rust ä¸­ï¼Œè¿™ç§ç»§æ‰¿å…³ç³»ä½¿ç”¨ [`Deref`](https://doc.rust-lang.org/std/ops/trait.Deref.html) å’Œ [`AsRef`](https://doc.rust-lang.org/std/convert/trait.AsRef.html) ç‰¹æ€§æ¥è¡¨ç¤ºã€‚è¿™é‡Œä¸¾ä¸ªä¾‹å­å¯èƒ½ä¼šæœ‰æ‰€å¸®åŠ©ï¼›å‡è®¾æ‚¨æœ‰ä¸‰ç§ç±»å‹ `A`ã€`B` å’Œ `C`ï¼Œå…¶ä¸­ `C` æ‰©å±•äº† `B`ï¼Œè€Œ `B` åˆæ‰©å±•äº† `A`ã€‚

When importing these types the `#[wasm-bindgen]` macro will implement the `Deref` and `AsRef`
traits in the following way:

åœ¨å¯¼å…¥è¿™äº›ç±»å‹æ—¶ï¼Œ`#[wasm-bindgen]` å®å°†æŒ‰ç…§ä»¥ä¸‹æ–¹å¼å®ç° `Deref` å’Œ `AsRef` ç‰¹æ€§ï¼š

-   `C` can `Deref` to `B`
-   `B` can `Deref` to `A`
-   `C` can be `AsRef` to `B`
-   Both `C` & `B` can be `AsRef` to `A`

-   `C` å¯ä»¥ `Deref` åˆ° `B`
-   `B` å¯ä»¥ `Deref` åˆ° `A`
-   `C` å¯ä»¥è¢« `AsRef` åˆ° `B`
-   `C` å’Œ `B` éƒ½å¯ä»¥è¢« `AsRef` åˆ° `A`

These implementations allow you to call a method from `A` on an instance of `C` and to use `C` as if
it was `&B` or `&A`.

è¿™äº›å®ç°å…è®¸æ‚¨åœ¨ `C` çš„å®ä¾‹ä¸Šè°ƒç”¨ `A` çš„æ–¹æ³•ï¼Œå¹¶å°† `C` ç”¨ä½œ `&B` æˆ– `&A`ã€‚

It is important to note that every single type imported using `#[wasm-bindgen]` has the same root type,
you can think of it as the `A` in the example above, this type is [`JsValue`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/struct.JsValue.html) which has
its section below.

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä½¿ç”¨ `#[wasm-bindgen]` å¯¼å…¥çš„æ¯ç§ç±»å‹éƒ½æœ‰ç›¸åŒçš„æ ¹ç±»å‹ï¼Œæ‚¨å¯ä»¥å°†å…¶è§†ä¸ºä¸Šé¢ç¤ºä¾‹ä¸­çš„ `A`ï¼Œè¿™ç§ç±»å‹æ˜¯ [`JsValue`](#jsvalue)ï¼Œä¸‹é¢æœ‰å®ƒçš„éƒ¨åˆ†ã€‚

_[extends section in The `wasm-bindgen` Guide](https://rustwasm.github.io/docs/wasm-bindgen/reference/attributes/on-js-imports/extends.html)_

_[`wasm-bindgen` æŒ‡å¼•ä¸­çš„ extends éƒ¨åˆ†](https://rustwasm.github.io/docs/wasm-bindgen/reference/attributes/on-js-imports/extends.html)_

### [`JsValue`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/struct.JsValue.html)

This is a representation of an object owned by JavaScript, this is a root catch-all type for `wasm-bindgen`.
Any type that comes from `wasm-bindgen` is a `JsValue` and this is because JavaScript does not have
a strong type system so any function that accepts a variable `x` does not define its type so `x` can be
a valid JavaScript value; hence `JsValue`. If you are working with imported functions or types that
accept a `JsValue`, then any imported value is _technically_ valid.

è¿™æ˜¯ JavaScript æ‹¥æœ‰çš„å¯¹è±¡çš„è¡¨ç¤ºï¼Œè¿™æ˜¯ `wasm-bindgen` çš„æ ¹æ•è·ç±»å‹ã€‚ä»»ä½•æ¥è‡ª `wasm-bindgen` çš„ç±»å‹éƒ½æ˜¯ `JsValue`ï¼Œè¿™æ˜¯å› ä¸º JavaScript æ²¡æœ‰å¼ºç±»å‹ç³»ç»Ÿï¼Œå› æ­¤æ¥å—å˜é‡ `x` çš„ä»»ä½•å‡½æ•°éƒ½ä¸å®šä¹‰å…¶ç±»å‹ï¼Œå› æ­¤ `x` å¯ä»¥æ˜¯æœ‰æ•ˆçš„ JavaScript å€¼ï¼›å› æ­¤ `JsValue`ã€‚å¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨æ¥å— `JsValue` çš„å¯¼å…¥å‡½æ•°æˆ–ç±»å‹ï¼Œé‚£ä¹ˆä»»ä½•å¯¼å…¥çš„å€¼åœ¨æŠ€æœ¯ä¸Šéƒ½æ˜¯æœ‰æ•ˆçš„ã€‚

`JsValue` can be accepted by a function but that function may still only accept certain types and this
can lead to panics - so when using raw `wasm-bindgen` APIs check the documentation of the JavaScript
being imported as to whether an exception (panic) will be raised if that value is not a certain type.

`JsValue` å¯ä»¥è¢«å‡½æ•°æ¥å—ï¼Œä½†è¯¥å‡½æ•°å¯èƒ½ä»ç„¶åªæ¥å—æŸäº›ç±»å‹ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´ panic - å› æ­¤åœ¨ä½¿ç”¨åŸå§‹ `wasm-bindgen` API æ—¶ï¼Œè¯·æ£€æŸ¥å¯¼å…¥çš„ JavaScript çš„æ–‡æ¡£ï¼Œä»¥ç¡®å®šæ˜¯å¦ä¼šåœ¨è¯¥å€¼ä¸æ˜¯æŸç§ç±»å‹æ—¶å¼•å‘å¼‚å¸¸ï¼ˆpanicï¼‰ã€‚

_[`JsValue` documentation](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/struct.JsValue.html)._

_[`JsValue` æ–‡æ¡£](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/struct.JsValue.html)ã€‚_

### [`JsCast`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html)

Rust has a strong type system and JavaScript...doesn't ğŸ˜. For Rust to maintain these
strong types but still be convenient, the WebAssembly group came up with a pretty neat trait `JsCast`.
Its job is to help you move from one JavaScript "type" to another, which sounds vague, but it means
that if you have one type which you know is another, then you can use the functions of `JsCast`
to jump from one type to the other. It is a nice trait to get to know when working with `web-sys`,
`wasm_bindgen`, `js-sys` - you will notice lots of types will implement `JsCast` from those crates.

Rust æœ‰ä¸€ä¸ªå¼ºç±»å‹ç³»ç»Ÿï¼Œè€Œ JavaScriptâ€¦â€¦æ²¡æœ‰ğŸ˜ã€‚ä¸ºäº†è®© Rust ä¿æŒè¿™äº›å¼ºç±»å‹ä½†ä»ç„¶æ–¹ä¾¿ï¼ŒWebAssembly å·¥ä½œç»„æå‡ºäº†ä¸€ä¸ªéå¸¸å·§å¦™çš„ç‰¹æ€§ `JsCast`ã€‚å®ƒçš„å·¥ä½œæ˜¯å¸®åŠ©æ‚¨ä»ä¸€ä¸ª JavaScript "ç±»å‹" è½¬æ¢åˆ°å¦ä¸€ä¸ª "ç±»å‹"ï¼Œè¿™å¬èµ·æ¥å¾ˆæ¨¡ç³Šï¼Œä½†å®ƒæ„å‘³ç€å¦‚æœæ‚¨æœ‰ä¸€ä¸ªç±»å‹ï¼Œæ‚¨çŸ¥é“å®ƒæ˜¯å¦ä¸€ä¸ªç±»å‹ï¼Œé‚£ä¹ˆæ‚¨å¯ä»¥ä½¿ç”¨ `JsCast` çš„å‡½æ•°ä»ä¸€ä¸ªç±»å‹è·³åˆ°å¦ä¸€ä¸ªç±»å‹ã€‚å½“ä½¿ç”¨ `web-sys`ã€`wasm_bindgen`ã€`js-sys` æ—¶ï¼Œäº†è§£è¿™ä¸ªå¾ˆå¥½çš„ç‰¹æ€§ - æ‚¨ä¼šæ³¨æ„åˆ°è®¸å¤šç±»å‹å°†ä»è¿™äº› crate ä¸­å®ç° `JsCast`ã€‚

`JsCast` provides both checked and unchecked methods of casting - so that at runtime if you are
unsure what type a certain object is you can try to cast it which returns possible failure types like
[`Option`](https://doc.rust-lang.org/std/option/enum.Option.html) and
[`Result`](https://doc.rust-lang.org/std/result/enum.Result.html).

`JsCast` æä¾›äº†è½¬æ¢çš„æ£€æŸ¥å’Œä¸æ£€æŸ¥æ–¹æ³• - å› æ­¤åœ¨è¿è¡Œæ—¶ï¼Œå¦‚æœæ‚¨ä¸ç¡®å®šæŸä¸ªå¯¹è±¡æ˜¯ä»€ä¹ˆç±»å‹ï¼Œæ‚¨å¯ä»¥å°è¯•å°†å…¶è½¬æ¢ï¼Œè¿™å°†è¿”å›å¯èƒ½çš„å¤±è´¥ç±»å‹ï¼Œå¦‚ [`Option`](https://doc.rust-lang.org/std/option/enum.Option.html) å’Œ [`Result`](https://doc.rust-lang.org/std/result/enum.Result.html)ã€‚

ä¸€ä¸ªå¸¸è§çš„ä¾‹å­æ˜¯åœ¨ [`web-sys`](./web-sys.mdx) ä¸­ï¼Œå½“æ‚¨å°è¯•è·å–äº‹ä»¶çš„ç›®æ ‡æ—¶ã€‚æ‚¨å¯èƒ½çŸ¥é“ç›®æ ‡å…ƒç´ æ˜¯ä»€ä¹ˆï¼Œä½† [`web_sys::Event`](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Event.html) API æ€»æ˜¯ä¼šè¿”å›ä¸€ä¸ª [`Option<web_sys::EventTarget>`](https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Event.html#method.target)ã€‚
æ‚¨éœ€è¦å°†å…¶è½¬æ¢ä¸ºå…ƒç´ ç±»å‹ï¼Œä»¥ä¾¿è°ƒç”¨å…¶æ–¹æ³•ã€‚

```rust
// need to import the trait.
use wasm_bindgen::JsCast;
use web_sys::{Event, EventTarget, HtmlInputElement, HtmlSelectElement};

fn handle_event(event: Event) {
    let target: EventTarget = event
        .target()
        .expect("I'm sure this event has a target!");

    // maybe the target is a select element?
    if let Some(select_element) = target.dyn_ref::<HtmlSelectElement>() {
        // do something amazing here
        return;
    }

    // if it wasn't a select element then I KNOW it's a input element!
    let input_element: HtmlInputElement = target.unchecked_into();
}
```

The [`dyn_ref`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html#method.dyn_ref)
method is a checked cast that returns an `Option<&T>` which means the original type
can be used again if the cast failed and thus returned `None`. The
[`dyn_into`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html#method.dyn_into)
method will consume `self`, as per convention for `into` methods in Rust, and the type returned is
`Result<T, Self>`. If the casting fails, the original `Self` value is returned in `Err`. You can try again
or do something else with the original type.

[`dyn_ref`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html#method.dyn_ref) æ–¹æ³•æ˜¯ä¸€ä¸ªæ£€æŸ¥çš„è½¬æ¢ï¼Œè¿”å›ä¸€ä¸ª `Option<&T>`ï¼Œè¿™æ„å‘³ç€å¦‚æœè½¬æ¢å¤±è´¥ï¼Œåˆ™å¯ä»¥å†æ¬¡ä½¿ç”¨åŸå§‹ç±»å‹ï¼Œå› æ­¤è¿”å› `None`ã€‚[`dyn_into`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html#method.dyn_into) æ–¹æ³•å°†æ¶ˆè€— `self`ï¼Œè¿™æ˜¯ Rust ä¸­ `into` æ–¹æ³•çš„çº¦å®šï¼Œè¿”å›çš„ç±»å‹æ˜¯ `Result<T, Self>`ã€‚å¦‚æœè½¬æ¢å¤±è´¥ï¼Œåˆ™åŸå§‹çš„ `Self` å€¼å°†åœ¨ `Err` ä¸­è¿”å›ã€‚æ‚¨å¯ä»¥å†è¯•ä¸€æ¬¡æˆ–å¯¹åŸå§‹ç±»å‹è¿›è¡Œå…¶ä»–æ“ä½œã€‚

_[`JsCast` documentation](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/trait.JsCast.html)._

### [`Closure`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html)

The `Closure` type provides a way to transfer Rust closures to JavaScript, the closures passed to
JavaScript must have a `'static` lifetime for soundness reasons.

`Closure` ç±»å‹æä¾›äº†ä¸€ç§å°† Rust é—­åŒ…ä¼ é€’åˆ° JavaScript çš„æ–¹æ³•ï¼Œå‡ºäºå¥å…¨æ€§åŸå› ï¼Œä¼ é€’ç»™ JavaScript çš„é—­åŒ…å¿…é¡»å…·æœ‰ `'static` ç”Ÿå‘½å‘¨æœŸã€‚

This type is a "handle" in the sense that whenever it is dropped it will invalidate the JS
closure that it refers to. Any usage of the closure in JS after the Closure has been dropped will
raise an exception.

è¿™ç§ç±»å‹æ˜¯ä¸€ä¸ªâ€œå¥æŸ„â€ï¼Œæ„å‘³ç€æ¯å½“å®ƒè¢«ä¸¢å¼ƒæ—¶ï¼Œå®ƒå°†ä½¿å…¶å¼•ç”¨çš„ JS é—­åŒ…æ— æ•ˆã€‚åœ¨ `Closure` è¢«ä¸¢å¼ƒåï¼Œå¯¹ JS ä¸­é—­åŒ…çš„ä»»ä½•ä½¿ç”¨éƒ½å°†å¼•å‘å¼‚å¸¸ã€‚

`Closure` is often used when you are working with a `js-sys` or `web-sys` API that accepts a type
[`&js_sys::Function`](https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Function.html).
An example of using a `Closure` in Yew can be found in the [Using `Closure` section](../html/events.mdx#using-closure-verbose)
on the [Events](../html/events.mdx) page.

å½“æ‚¨ä½¿ç”¨æ¥å—ç±»å‹ [`&js_sys::Function`](https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Function.html) çš„ `js-sys` æˆ– `web-sys` API æ—¶ï¼Œé€šå¸¸ä¼šä½¿ç”¨ `Closure`ã€‚åœ¨ [Events](../html/events.mdx) é¡µé¢çš„ [Using `Closure` éƒ¨åˆ†](../html/events.mdx#using-closure-verbose) ä¸­å¯ä»¥æ‰¾åˆ°åœ¨ Yew ä¸­ä½¿ç”¨ `Closure` çš„ç¤ºä¾‹ã€‚

_[`Closure` æ–‡æ¡£](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html)._

## [`js-sys`](https://crates.io/crates/js-sys)

The `js-sys` crate provides bindings/imports of JavaScript's standard, built-in objects, including
their methods and properties.

`js-sys` crate æä¾›äº† JavaScript æ ‡å‡†å†…ç½®å¯¹è±¡çš„ç»‘å®š/å¯¼å…¥ï¼ŒåŒ…æ‹¬å®ƒä»¬çš„æ–¹æ³•å’Œå±æ€§ã€‚

This does not include any web APIs as this is what [`web-sys`](./web-sys.mdx) is for!

è¿™ä¸åŒ…æ‹¬ä»»ä½• Web APIï¼Œå› ä¸ºè¿™æ˜¯ [`web-sys`](./web-sys.mdx) çš„ä½œç”¨ï¼

_[`js-sys` æ–‡æ¡£](https://rustwasm.github.io/wasm-bindgen/api/js_sys/index.html)._

## [`wasm-bindgen-futures`](https://crates.io/crates/wasm-bindgen-futures)

The `wasm-bindgen-futures` crate provides a bridge for working with JavaScript Promise types as a
Rust [`Future`](https://doc.rust-lang.org/stable/std/future/trait.Future.html), and contains
utilities to turn a rust Future into a JavaScript Promise. This can be useful when working with
asynchronous or otherwise blocking work in Rust (wasm), and provides the ability to interoperate
with JavaScript events and JavaScript I/O primitives.

`wasm-bindgen-futures` crate æä¾›äº†ä¸€ä¸ªæ¡¥æ¢ï¼Œç”¨äºå°† JavaScript Promise ç±»å‹ä½œä¸º Rust [`Future`](https://doc.rust-lang.org/stable/std/future/trait.Future.html) è¿›è¡Œå¤„ç†ï¼Œå¹¶åŒ…å«å°† Rust Future è½¬æ¢ä¸º JavaScript Promise çš„å®ç”¨ç¨‹åºã€‚å½“åœ¨ Rustï¼ˆwasmï¼‰ä¸­å¤„ç†å¼‚æ­¥æˆ–å…¶ä»–é˜»å¡å·¥ä½œæ—¶ï¼Œè¿™å¯èƒ½å¾ˆæœ‰ç”¨ï¼Œå¹¶æä¾›äº†ä¸ JavaScript äº‹ä»¶å’Œ JavaScript I/O åŸè¯­è¿›è¡Œäº¤äº’çš„èƒ½åŠ›ã€‚

There are three main interfaces in this crate currently:

ç›®å‰è¿™ä¸ª crate ä¸­æœ‰ä¸‰ä¸ªä¸»è¦æ¥å£ï¼š

1. [`JsFuture`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/struct.JsFuture.html) -
   A type that is constructed with a [`Promise`](https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Promise.html)
   and can then be used as a `Future<Output=Result<JsValue, JsValue>>`. This `Future` will resolve to `Ok` if
   the `Promise` is resolved and `Err` if the `Promise` is rejected, containing the resolved or rejected
   value from the `Promise` respectively.

1. [`JsFuture`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/struct.JsFuture.html) -
   ä¸€ä¸ªä½¿ç”¨ [`Promise`](https://rustwasm.github.io/wasm-bindgen/api/js_sys/struct.Promise.html) æ„é€ çš„ç±»å‹ï¼Œç„¶åå¯ä»¥ç”¨ä½œ `Future<Output=Result<JsValue, JsValue>>`ã€‚å¦‚æœ `Promise` è¢«è§£æï¼Œè¿™ä¸ª `Future` å°†è§£æä¸º `Ok`ï¼Œå¦‚æœ `Promise` è¢«æ‹’ç»ï¼Œåˆ™è§£æä¸º `Err`ï¼Œåˆ†åˆ«åŒ…å« `Promise` çš„è§£ææˆ–æ‹’ç»å€¼ã€‚

2. [`future_to_promise`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.future_to_promise.html) -
   Converts a Rust `Future<Output=Result<JsValue, JsValue>>` into a
   JavaScript `Promise`. The futureâ€™s result will translate to either a resolved or rejected
   `Promise` in JavaScript.

2. [`future_to_promise`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.future_to_promise.html) -
   å°† Rust `Future<Output=Result<JsValue, JsValue>>` è½¬æ¢ä¸º JavaScript `Promise`ã€‚æœªæ¥çš„ç»“æœå°†è½¬æ¢ä¸º JavaScript ä¸­çš„å·²è§£ææˆ–å·²æ‹’ç» `Promise`ã€‚

3. [`spawn_local`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.spawn_local.html) -
   Spawns a `Future<Output = ()>` on the current thread. This is the best way
   to run a Future in Rust without sending it to JavaScript.

3. [`spawn_local`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.spawn_local.html) -
   åœ¨å½“å‰çº¿ç¨‹ä¸Šç”Ÿæˆä¸€ä¸ª `Future<Output = ()>`ã€‚è¿™æ˜¯åœ¨ Rust ä¸­è¿è¡Œ Future çš„æœ€ä½³æ–¹æ³•ï¼Œè€Œä¸æ˜¯å°†å…¶å‘é€åˆ° JavaScriptã€‚

_[`wasm-bindgen-futures` æ–‡æ¡£](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/index.html)._

### [`spawn_local`](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.spawn_local.html)

`spawn_local` is going to be the most commonly used part of the `wasm-bindgen-futures` crate in Yew
as this helps when using libraries that have async APIs.

`spawn_local` å°†æ˜¯ Yew ä¸­ `wasm-bindgen-futures` crate ä¸­æœ€å¸¸ç”¨çš„éƒ¨åˆ†ï¼Œå› ä¸ºè¿™æœ‰åŠ©äºä½¿ç”¨å…·æœ‰å¼‚æ­¥ API çš„åº“ã€‚

```rust ,no_run
use web_sys::console;
use wasm_bindgen_futures::spawn_local;

async fn my_async_fn() -> String { String::from("Hello") }

spawn_local(async {
    let mut string = my_async_fn().await;
    string.push_str(", world!");
    // console log "Hello, world!"
    console::log_1(&string.into());
});
```

Yew has also added support for futures in certain APIs, most notably you can create a
`callback_future` which accepts an `async` block - this uses `spawn_local` internally.

Yew è¿˜åœ¨æŸäº› API ä¸­æ·»åŠ äº†å¯¹ futures çš„æ”¯æŒï¼Œæœ€å€¼å¾—æ³¨æ„çš„æ˜¯æ‚¨å¯ä»¥åˆ›å»ºä¸€ä¸ªæ¥å— `async` å—çš„ `callback_future` - è¿™åœ¨å†…éƒ¨ä½¿ç”¨äº† `spawn_local`ã€‚

_[`spawn_local` æ–‡æ¡£](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/fn.spawn_local.html)._
