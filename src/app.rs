//! This module contains `App` sctruct which used to bootstrap
//! a component in an isolated scope.

use crate::html::{Component, Renderable, Scope};
use stdweb::web::{document, Element, INode, IParentNode};

/// An application instance.
pub struct App<COMP: Component> {
    /// `Scope` holder
    scope: Scope<COMP>,
}

impl<COMP> App<COMP>
where
    COMP: Component<Properties = ()> + Renderable<COMP>,
{
    /// Creates a new `App` with a component in a context.
    pub fn new() -> Self {
        let scope = Scope::new();
        App { scope }
    }

    /// Alias to `mount_in_place` taking a component having a body element at the
    /// root of the HTML generated by its `view` method. Use this method when you
    /// need to manipulate the body element. For example, adding/removing app-wide
    /// CSS classes of the body element.
    pub fn mount_body(self) -> Scope<COMP> {
        let html_element = document()
            .query_selector("html")
            .expect("can't get html node for rendering")
            .expect("can't unwrap html node");
        let body_element = document()
            .query_selector("body")
            .expect("can't get body node for rendering")
            .expect("can't unwrap body node");
        html_element.remove_child(&body_element).expect("can't remove body child");
        self.scope.mount_in_place(html_element, None, None, None)
    }

    /// Alias to `mount("body", ...)`.
    pub fn mount_to_body(self) -> Scope<COMP> {
        // Bootstrap the component for `Window` environment only (not for `Worker`)
        let element = document()
            .query_selector("body")
            .expect("can't get body node for rendering")
            .expect("can't unwrap body node");
        self.mount(element)
    }

    /// The main entrypoint of a yew program. It works similar as `program`
    /// function in Elm. You should provide an initial model, `update` function
    /// which will update the state of the model and a `view` function which
    /// will render the model to a virtual DOM tree.
    pub fn mount(self, element: Element) -> Scope<COMP> {
        clear_element(&element);
        self.scope.mount_in_place(element, None, None, ())
    }
}

/// Removes anything from the given element.
fn clear_element(element: &Element) {
    while let Some(child) = element.last_child() {
        element.remove_child(&child).expect("can't remove a child");
    }
}
