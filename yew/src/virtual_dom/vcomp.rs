//! This module contains the implementation of a virtual component `VComp`.

use super::{Key, Transformer, VDiff, VDiffNodePosition, VNode};
use crate::html::{AnyScope, Component, ComponentUpdate, NodeRef, Scope};
use crate::utils::document;
use cfg_if::cfg_if;
use std::any::TypeId;
use std::fmt;
use std::rc::Rc;
cfg_if! {
    if #[cfg(feature = "std_web")] {
        use stdweb::web::{Element, INode, Node, TextNode};
    } else if #[cfg(feature = "web_sys")] {
        use web_sys::{Element, Node, Text as TextNode};
    }
}

/// The method generates an instance of a component.
type Generator = dyn Fn(GeneratorType) -> Mounted;

/// Components can be generated by mounting or by overwriting an old component.
enum GeneratorType {
    Mount(AnyScope, Element, TextNode),
    Overwrite(AnyScope),
}

/// A virtual component.
#[derive(Clone)]
pub struct VComp {
    type_id: TypeId,
    state: MountState,
    pub(crate) node_ref: NodeRef,
    pub(crate) key: Option<Key>,
}

/// A virtual child component.
pub struct VChild<COMP: Component> {
    /// The component properties
    pub props: COMP::Properties,
    /// Reference to the mounted node
    node_ref: NodeRef,
    key: Option<Key>,
}

impl<COMP: Component> Clone for VChild<COMP> {
    fn clone(&self) -> Self {
        VChild {
            props: self.props.clone(),
            node_ref: self.node_ref.clone(),
            key: self.key.clone(),
        }
    }
}

impl<COMP: Component> PartialEq for VChild<COMP>
where
    COMP::Properties: PartialEq,
{
    fn eq(&self, other: &VChild<COMP>) -> bool {
        self.props == other.props
    }
}

impl<COMP> VChild<COMP>
where
    COMP: Component,
{
    /// Creates a child component that can be accessed and modified by its parent.
    pub fn new(props: COMP::Properties, node_ref: NodeRef, key: Option<Key>) -> Self {
        Self {
            props,
            node_ref,
            key,
        }
    }
}

impl<COMP> From<VChild<COMP>> for VComp
where
    COMP: Component,
{
    fn from(vchild: VChild<COMP>) -> Self {
        VComp::new::<COMP>(vchild.props, vchild.node_ref, vchild.key)
    }
}

#[derive(Clone)]
enum MountState {
    Unmounted(Unmounted),
    Mounted(Mounted),
    Mounting,
    Detached,
    Overwritten,
}

#[derive(Clone)]
struct Unmounted {
    generator: Rc<Generator>,
}

struct Mounted {
    node_ref: NodeRef,
    scope: AnyScope,
    destroyer: Box<dyn FnOnce()>,
}

impl Clone for Mounted {
    fn clone(&self) -> Self {
        panic!("Mounted components are not allowed to be cloned!")
    }
}

impl VComp {
    /// This method prepares a generator to make a new instance of the `Component`.
    pub fn new<COMP>(props: COMP::Properties, node_ref: NodeRef, key: Option<Key>) -> Self
    where
        COMP: Component,
    {
        let node_ref_clone = node_ref.clone();
        let generator = move |generator_type: GeneratorType| -> Mounted {
            match generator_type {
                GeneratorType::Mount(parent_scope, element, dummy_node) => {
                    let scope: Scope<COMP> = Scope::new(Some(parent_scope));

                    let mut scope = scope.mount_in_place(
                        element,
                        Some(VNode::VRef(dummy_node.into())),
                        node_ref_clone.clone(),
                        props.clone(),
                    );

                    Mounted {
                        node_ref: node_ref_clone.clone(),
                        scope: scope.clone().into(),
                        destroyer: Box::new(move || scope.destroy()),
                    }
                }
                GeneratorType::Overwrite(any_scope) => {
                    let mut scope: Scope<COMP> = any_scope.downcast();
                    scope.update(
                        ComponentUpdate::Properties(props.clone(), node_ref_clone.clone()),
                        false,
                    );

                    Mounted {
                        node_ref: node_ref_clone.clone(),
                        scope: scope.clone().into(),
                        destroyer: Box::new(move || scope.destroy()),
                    }
                }
            }
        };

        VComp {
            type_id: TypeId::of::<COMP>(),
            state: MountState::Unmounted(Unmounted {
                generator: Rc::new(generator),
            }),
            node_ref,
            key,
        }
    }
}

impl Unmounted {
    /// Mount a virtual component using a generator.
    fn mount(self, parent_scope: AnyScope, parent: Element, dummy_node: TextNode) -> Mounted {
        (self.generator)(GeneratorType::Mount(parent_scope, parent, dummy_node))
    }

    /// Overwrite an existing virtual component using a generator.
    fn replace(self, old: Mounted) -> Mounted {
        (self.generator)(GeneratorType::Overwrite(old.scope))
    }
}

enum Reform {
    Keep(Mounted),
    Replace(VDiffNodePosition),
}

impl VDiff for VComp {
    fn detach(&mut self, _parent: &Element) -> VDiffNodePosition {
        match core::mem::replace(&mut self.state, MountState::Detached) {
            MountState::Mounted(this) => {
                (this.destroyer)();
                match this.node_ref.get().and_then(|n| n.next_sibling()) {
                    Some(node) => VDiffNodePosition::Before(node),
                    None => VDiffNodePosition::LastChild,
                }
            }
            _ => VDiffNodePosition::LastChild,
        }
    }

    fn apply(
        &mut self,
        parent_scope: &AnyScope,
        parent: &Element,
        node_position: VDiffNodePosition,
        ancestor: Option<VNode>,
    ) -> Option<Node> {
        if let MountState::Unmounted(this) =
            core::mem::replace(&mut self.state, MountState::Mounting)
        {
            let reform = match ancestor {
                Some(VNode::VComp(mut vcomp)) => {
                    // If the ancestor is a Component of the same type, don't replace, keep the
                    // old Component but update the properties.
                    if self.type_id == vcomp.type_id {
                        match core::mem::replace(&mut vcomp.state, MountState::Overwritten) {
                            MountState::Mounted(mounted) => Reform::Keep(mounted),
                            _ => Reform::Replace(node_position),
                        }
                    } else {
                        Reform::Replace(vcomp.detach(parent))
                    }
                }
                Some(mut vnode) => Reform::Replace(vnode.detach(parent)),
                None => Reform::Replace(node_position),
            };

            let (mounted, node) = match reform {
                Reform::Keep(mounted) => {
                    // Send properties update when the component is already rendered.
                    let node = mounted
                        .node_ref
                        .get()
                        .expect("mounted VComp must have a node_ref");
                    (this.replace(mounted), node)
                }
                Reform::Replace(position) => {
                    // TODO: Revert dummy text for VComp
                    let dummy_node = document().create_text_node("DUMMY NODE FOR COMPONENT");
                    let node: Node = dummy_node.clone().into();

                    super::insert_node(&dummy_node, parent, &position);

                    let mounted = this.mount(parent_scope.clone(), parent.to_owned(), dummy_node);
                    (mounted, node)
                }
            };

            self.state = MountState::Mounted(mounted);
            Some(node)
        } else {
            None
        }
    }
}

impl<T> Transformer<T, T> for VComp {
    fn transform(from: T) -> T {
        from
    }
}

impl<'a, T> Transformer<&'a T, T> for VComp
where
    T: Clone,
{
    fn transform(from: &'a T) -> T {
        from.clone()
    }
}

impl<'a> Transformer<&'a str, String> for VComp {
    fn transform(from: &'a str) -> String {
        from.to_owned()
    }
}

impl<T> Transformer<T, Option<T>> for VComp {
    fn transform(from: T) -> Option<T> {
        Some(from)
    }
}

impl<'a, T> Transformer<&'a T, Option<T>> for VComp
where
    T: Clone,
{
    fn transform(from: &T) -> Option<T> {
        Some(from.clone())
    }
}

impl<'a> Transformer<&'a str, Option<String>> for VComp {
    fn transform(from: &'a str) -> Option<String> {
        Some(from.to_owned())
    }
}

impl<'a> Transformer<Option<&'a str>, Option<String>> for VComp {
    fn transform(from: Option<&'a str>) -> Option<String> {
        from.map(|s| s.to_owned())
    }
}

impl PartialEq for VComp {
    fn eq(&self, other: &VComp) -> bool {
        self.type_id == other.type_id
    }
}

impl fmt::Debug for VComp {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("VComp").field("key", &self.key).finish()
    }
}

impl<COMP: Component> fmt::Debug for VChild<COMP> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str("VChild<_>")
    }
}

#[cfg(test)]
mod tests {
    use super::VChild;
    use crate::macros::Properties;
    use crate::{html, Component, ComponentLink, Html, NodeRef, ShouldRender};
    #[cfg(feature = "wasm_test")]
    use wasm_bindgen_test::{wasm_bindgen_test as test, wasm_bindgen_test_configure};

    #[cfg(feature = "wasm_test")]
    wasm_bindgen_test_configure!(run_in_browser);

    struct Comp;

    #[derive(Clone, PartialEq, Properties)]
    struct Props {
        #[prop_or_default]
        field_1: u32,
        #[prop_or_default]
        field_2: u32,
    }

    impl Component for Comp {
        type Message = ();
        type Properties = Props;

        fn create(_: Self::Properties, _: ComponentLink<Self>) -> Self {
            Comp
        }

        fn update(&mut self, _: Self::Message) -> ShouldRender {
            unimplemented!();
        }

        fn change(&mut self, _: Self::Properties) -> ShouldRender {
            unimplemented!();
        }

        fn view(&self) -> Html {
            unimplemented!();
        }
    }

    #[test]
    fn set_properties_to_component() {
        html! {
            <Comp />
        };

        html! {
            <Comp field_1=1 />
        };

        html! {
            <Comp field_2=2 />
        };

        html! {
            <Comp field_1=1 field_2=2 />
        };

        let props = Props {
            field_1: 1,
            field_2: 1,
        };

        html! {
            <Comp with props />
        };
    }

    #[test]
    fn vchild_partialeq() {
        let vchild1: VChild<Comp> = VChild::new(
            Props {
                field_1: 1,
                field_2: 1,
            },
            NodeRef::default(),
            None,
        );

        let vchild2: VChild<Comp> = VChild::new(
            Props {
                field_1: 1,
                field_2: 1,
            },
            NodeRef::default(),
            None,
        );

        let vchild3: VChild<Comp> = VChild::new(
            Props {
                field_1: 2,
                field_2: 2,
            },
            NodeRef::default(),
            None,
        );

        assert_eq!(vchild1, vchild2);
        assert_ne!(vchild1, vchild3);
        assert_ne!(vchild2, vchild3);
    }
}
